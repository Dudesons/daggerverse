// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"main/internal/dagger"
	"os"
)

var dag = dagger.Connect()

type DaggerObject = dagger.DaggerObject

type ExecError = dagger.ExecError

// The `AutodetectionID` scalar type represents an identifier for an object of type Autodetection.
type AutodetectionID = dagger.AutodetectionID

// The `AutodetectionNodeAnalyzerID` scalar type represents an identifier for an object of type AutodetectionNodeAnalyzer.
type AutodetectionNodeAnalyzerID = dagger.AutodetectionNodeAnalyzerID

// The `AutodetectionOciAnalyzerID` scalar type represents an identifier for an object of type AutodetectionOciAnalyzer.
type AutodetectionOciAnalyzerID = dagger.AutodetectionOciAnalyzerID

// The `CacheVolumeID` scalar type represents an identifier for an object of type CacheVolume.
type CacheVolumeID = dagger.CacheVolumeID

// The `ContainerID` scalar type represents an identifier for an object of type Container.
type ContainerID = dagger.ContainerID

// The `CurrentModuleID` scalar type represents an identifier for an object of type CurrentModule.
type CurrentModuleID = dagger.CurrentModuleID

// The `DirectoryID` scalar type represents an identifier for an object of type Directory.
type DirectoryID = dagger.DirectoryID

// The `EnvVariableID` scalar type represents an identifier for an object of type EnvVariable.
type EnvVariableID = dagger.EnvVariableID

// The `FieldTypeDefID` scalar type represents an identifier for an object of type FieldTypeDef.
type FieldTypeDefID = dagger.FieldTypeDefID

// The `FileID` scalar type represents an identifier for an object of type File.
type FileID = dagger.FileID

// The `FunctionArgID` scalar type represents an identifier for an object of type FunctionArg.
type FunctionArgID = dagger.FunctionArgID

// The `FunctionCallArgValueID` scalar type represents an identifier for an object of type FunctionCallArgValue.
type FunctionCallArgValueID = dagger.FunctionCallArgValueID

// The `FunctionCallID` scalar type represents an identifier for an object of type FunctionCall.
type FunctionCallID = dagger.FunctionCallID

// The `FunctionID` scalar type represents an identifier for an object of type Function.
type FunctionID = dagger.FunctionID

// The `GeneratedCodeID` scalar type represents an identifier for an object of type GeneratedCode.
type GeneratedCodeID = dagger.GeneratedCodeID

// The `GitModuleSourceID` scalar type represents an identifier for an object of type GitModuleSource.
type GitModuleSourceID = dagger.GitModuleSourceID

// The `GitRefID` scalar type represents an identifier for an object of type GitRef.
type GitRefID = dagger.GitRefID

// The `GitRepositoryID` scalar type represents an identifier for an object of type GitRepository.
type GitRepositoryID = dagger.GitRepositoryID

// The `InputTypeDefID` scalar type represents an identifier for an object of type InputTypeDef.
type InputTypeDefID = dagger.InputTypeDefID

// The `InterfaceTypeDefID` scalar type represents an identifier for an object of type InterfaceTypeDef.
type InterfaceTypeDefID = dagger.InterfaceTypeDefID

// An arbitrary JSON-encoded value.
type JSON = dagger.JSON

// The `LabelID` scalar type represents an identifier for an object of type Label.
type LabelID = dagger.LabelID

// The `ListTypeDefID` scalar type represents an identifier for an object of type ListTypeDef.
type ListTypeDefID = dagger.ListTypeDefID

// The `LocalModuleSourceID` scalar type represents an identifier for an object of type LocalModuleSource.
type LocalModuleSourceID = dagger.LocalModuleSourceID

// The `ModuleDependencyID` scalar type represents an identifier for an object of type ModuleDependency.
type ModuleDependencyID = dagger.ModuleDependencyID

// The `ModuleID` scalar type represents an identifier for an object of type Module.
type ModuleID = dagger.ModuleID

// The `ModuleSourceID` scalar type represents an identifier for an object of type ModuleSource.
type ModuleSourceID = dagger.ModuleSourceID

// The `ObjectTypeDefID` scalar type represents an identifier for an object of type ObjectTypeDef.
type ObjectTypeDefID = dagger.ObjectTypeDefID

// The platform config OS and architecture in a Container.
//
// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
type Platform = dagger.Platform

// The `PortID` scalar type represents an identifier for an object of type Port.
type PortID = dagger.PortID

// The `SecretID` scalar type represents an identifier for an object of type Secret.
type SecretID = dagger.SecretID

// The `ServiceID` scalar type represents an identifier for an object of type Service.
type ServiceID = dagger.ServiceID

// The `SocketID` scalar type represents an identifier for an object of type Socket.
type SocketID = dagger.SocketID

// The `TerminalID` scalar type represents an identifier for an object of type Terminal.
type TerminalID = dagger.TerminalID

// The `TypeDefID` scalar type represents an identifier for an object of type TypeDef.
type TypeDefID = dagger.TypeDefID

// The absence of a value.
//
// A Null Void is used as a placeholder for resolvers that do not return anything.
type Void = dagger.Void

// Key value object that represents a build argument.
type BuildArg = dagger.BuildArg

// Key value object that represents a pipeline label.
type PipelineLabel = dagger.PipelineLabel

// Port forwarding rules for tunneling network traffic.
type PortForward = dagger.PortForward

type Autodetection = dagger.Autodetection

// AutodetectionNodeOpts contains options for Autodetection.Node
type AutodetectionNodeOpts = dagger.AutodetectionNodeOpts

// AutodetectionOciOpts contains options for Autodetection.Oci
type AutodetectionOciOpts = dagger.AutodetectionOciOpts

type AutodetectionNodeAnalyzer = dagger.AutodetectionNodeAnalyzer

type AutodetectionOciAnalyzer = dagger.AutodetectionOciAnalyzer

// A directory whose contents persist across runs.
type CacheVolume = dagger.CacheVolume

// An OCI-compatible container, also known as a Docker container.
type Container = dagger.Container

type WithContainerFunc = dagger.WithContainerFunc

// ContainerAsTarballOpts contains options for Container.AsTarball
type ContainerAsTarballOpts = dagger.ContainerAsTarballOpts

// ContainerBuildOpts contains options for Container.Build
type ContainerBuildOpts = dagger.ContainerBuildOpts

// ContainerExportOpts contains options for Container.Export
type ContainerExportOpts = dagger.ContainerExportOpts

// ContainerImportOpts contains options for Container.Import
type ContainerImportOpts = dagger.ContainerImportOpts

// ContainerPipelineOpts contains options for Container.Pipeline
type ContainerPipelineOpts = dagger.ContainerPipelineOpts

// ContainerPublishOpts contains options for Container.Publish
type ContainerPublishOpts = dagger.ContainerPublishOpts

// ContainerTerminalOpts contains options for Container.Terminal
type ContainerTerminalOpts = dagger.ContainerTerminalOpts

// ContainerWithDirectoryOpts contains options for Container.WithDirectory
type ContainerWithDirectoryOpts = dagger.ContainerWithDirectoryOpts

// ContainerWithEntrypointOpts contains options for Container.WithEntrypoint
type ContainerWithEntrypointOpts = dagger.ContainerWithEntrypointOpts

// ContainerWithEnvVariableOpts contains options for Container.WithEnvVariable
type ContainerWithEnvVariableOpts = dagger.ContainerWithEnvVariableOpts

// ContainerWithExecOpts contains options for Container.WithExec
type ContainerWithExecOpts = dagger.ContainerWithExecOpts

// ContainerWithExposedPortOpts contains options for Container.WithExposedPort
type ContainerWithExposedPortOpts = dagger.ContainerWithExposedPortOpts

// ContainerWithFileOpts contains options for Container.WithFile
type ContainerWithFileOpts = dagger.ContainerWithFileOpts

// ContainerWithFilesOpts contains options for Container.WithFiles
type ContainerWithFilesOpts = dagger.ContainerWithFilesOpts

// ContainerWithMountedCacheOpts contains options for Container.WithMountedCache
type ContainerWithMountedCacheOpts = dagger.ContainerWithMountedCacheOpts

// ContainerWithMountedDirectoryOpts contains options for Container.WithMountedDirectory
type ContainerWithMountedDirectoryOpts = dagger.ContainerWithMountedDirectoryOpts

// ContainerWithMountedFileOpts contains options for Container.WithMountedFile
type ContainerWithMountedFileOpts = dagger.ContainerWithMountedFileOpts

// ContainerWithMountedSecretOpts contains options for Container.WithMountedSecret
type ContainerWithMountedSecretOpts = dagger.ContainerWithMountedSecretOpts

// ContainerWithNewFileOpts contains options for Container.WithNewFile
type ContainerWithNewFileOpts = dagger.ContainerWithNewFileOpts

// ContainerWithUnixSocketOpts contains options for Container.WithUnixSocket
type ContainerWithUnixSocketOpts = dagger.ContainerWithUnixSocketOpts

// ContainerWithoutEntrypointOpts contains options for Container.WithoutEntrypoint
type ContainerWithoutEntrypointOpts = dagger.ContainerWithoutEntrypointOpts

// ContainerWithoutExposedPortOpts contains options for Container.WithoutExposedPort
type ContainerWithoutExposedPortOpts = dagger.ContainerWithoutExposedPortOpts

// Reflective module API provided to functions at runtime.
type CurrentModule = dagger.CurrentModule

// CurrentModuleWorkdirOpts contains options for CurrentModule.Workdir
type CurrentModuleWorkdirOpts = dagger.CurrentModuleWorkdirOpts

// A directory.
type Directory = dagger.Directory

type WithDirectoryFunc = dagger.WithDirectoryFunc

// DirectoryAsModuleOpts contains options for Directory.AsModule
type DirectoryAsModuleOpts = dagger.DirectoryAsModuleOpts

// DirectoryDockerBuildOpts contains options for Directory.DockerBuild
type DirectoryDockerBuildOpts = dagger.DirectoryDockerBuildOpts

// DirectoryEntriesOpts contains options for Directory.Entries
type DirectoryEntriesOpts = dagger.DirectoryEntriesOpts

// DirectoryPipelineOpts contains options for Directory.Pipeline
type DirectoryPipelineOpts = dagger.DirectoryPipelineOpts

// DirectoryWithDirectoryOpts contains options for Directory.WithDirectory
type DirectoryWithDirectoryOpts = dagger.DirectoryWithDirectoryOpts

// DirectoryWithFileOpts contains options for Directory.WithFile
type DirectoryWithFileOpts = dagger.DirectoryWithFileOpts

// DirectoryWithFilesOpts contains options for Directory.WithFiles
type DirectoryWithFilesOpts = dagger.DirectoryWithFilesOpts

// DirectoryWithNewDirectoryOpts contains options for Directory.WithNewDirectory
type DirectoryWithNewDirectoryOpts = dagger.DirectoryWithNewDirectoryOpts

// DirectoryWithNewFileOpts contains options for Directory.WithNewFile
type DirectoryWithNewFileOpts = dagger.DirectoryWithNewFileOpts

// An environment variable name and value.
type EnvVariable = dagger.EnvVariable

// A definition of a field on a custom object defined in a Module.
//
// A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
type FieldTypeDef = dagger.FieldTypeDef

// A file.
type File = dagger.File

type WithFileFunc = dagger.WithFileFunc

// FileExportOpts contains options for File.Export
type FileExportOpts = dagger.FileExportOpts

// Function represents a resolver provided by a Module.
//
// A function always evaluates against a parent object and is given a set of named arguments.
type Function = dagger.Function

type WithFunctionFunc = dagger.WithFunctionFunc

// FunctionWithArgOpts contains options for Function.WithArg
type FunctionWithArgOpts = dagger.FunctionWithArgOpts

// An argument accepted by a function.
//
// This is a specification for an argument at function definition time, not an argument passed at function call time.
type FunctionArg = dagger.FunctionArg

// An active function call.
type FunctionCall = dagger.FunctionCall

// A value passed as a named argument to a function call.
type FunctionCallArgValue = dagger.FunctionCallArgValue

// The result of running an SDK's codegen.
type GeneratedCode = dagger.GeneratedCode

type WithGeneratedCodeFunc = dagger.WithGeneratedCodeFunc

// Module source originating from a git repo.
type GitModuleSource = dagger.GitModuleSource

// A git ref (tag, branch, or commit).
type GitRef = dagger.GitRef

// GitRefTreeOpts contains options for GitRef.Tree
type GitRefTreeOpts = dagger.GitRefTreeOpts

// A git repository.
type GitRepository = dagger.GitRepository

// A graphql input type, which is essentially just a group of named args.
// This is currently only used to represent pre-existing usage of graphql input types
// in the core API. It is not used by user modules and shouldn't ever be as user
// module accept input objects via their id rather than graphql input types.
type InputTypeDef = dagger.InputTypeDef

// A definition of a custom interface defined in a Module.
type InterfaceTypeDef = dagger.InterfaceTypeDef

// A simple key value object that represents a label.
type Label = dagger.Label

// A definition of a list type in a Module.
type ListTypeDef = dagger.ListTypeDef

// Module source that that originates from a path locally relative to an arbitrary directory.
type LocalModuleSource = dagger.LocalModuleSource

// A Dagger module.
type Module = dagger.Module

type WithModuleFunc = dagger.WithModuleFunc

// The configuration of dependency of a module.
type ModuleDependency = dagger.ModuleDependency

// The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
type ModuleSource = dagger.ModuleSource

type WithModuleSourceFunc = dagger.WithModuleSourceFunc

// A definition of a custom object defined in a Module.
type ObjectTypeDef = dagger.ObjectTypeDef

// A port exposed by a container.
type Port = dagger.Port

// The root of the DAG.
type Client = dagger.Client

type WithClientFunc = dagger.WithClientFunc

// ContainerOpts contains options for Client.Container
type ContainerOpts = dagger.ContainerOpts

// DirectoryOpts contains options for Client.Directory
type DirectoryOpts = dagger.DirectoryOpts

// GitOpts contains options for Client.Git
type GitOpts = dagger.GitOpts

// HTTPOpts contains options for Client.HTTP
type HTTPOpts = dagger.HTTPOpts

// ModuleDependencyOpts contains options for Client.ModuleDependency
type ModuleDependencyOpts = dagger.ModuleDependencyOpts

// ModuleSourceOpts contains options for Client.ModuleSource
type ModuleSourceOpts = dagger.ModuleSourceOpts

// PipelineOpts contains options for Client.Pipeline
type PipelineOpts = dagger.PipelineOpts

// SecretOpts contains options for Client.Secret
type SecretOpts = dagger.SecretOpts

// A reference to a secret value, which can be handled more safely than the value itself.
type Secret = dagger.Secret

// A content-addressed service providing TCP connectivity.
type Service = dagger.Service

// ServiceEndpointOpts contains options for Service.Endpoint
type ServiceEndpointOpts = dagger.ServiceEndpointOpts

// ServiceStopOpts contains options for Service.Stop
type ServiceStopOpts = dagger.ServiceStopOpts

// ServiceUpOpts contains options for Service.Up
type ServiceUpOpts = dagger.ServiceUpOpts

// A Unix or TCP/IP socket that can be mounted into a container.
type Socket = dagger.Socket

// An interactive terminal that clients can connect to.
type Terminal = dagger.Terminal

// A definition of a parameter or return type in a Module.
type TypeDef = dagger.TypeDef

type WithTypeDefFunc = dagger.WithTypeDefFunc

// TypeDefWithFieldOpts contains options for TypeDef.WithField
type TypeDefWithFieldOpts = dagger.TypeDefWithFieldOpts

// TypeDefWithInterfaceOpts contains options for TypeDef.WithInterface
type TypeDefWithInterfaceOpts = dagger.TypeDefWithInterfaceOpts

// TypeDefWithObjectOpts contains options for TypeDef.WithObject
type TypeDefWithObjectOpts = dagger.TypeDefWithObjectOpts

// Sharing mode of the cache volume.
type CacheSharingMode = dagger.CacheSharingMode

const (
	// Shares the cache volume amongst many build pipelines, but will serialize the writes
	Locked CacheSharingMode = dagger.Locked

	// Keeps a cache volume for a single build pipeline
	Private CacheSharingMode = dagger.Private

	// Shares the cache volume amongst many build pipelines
	Shared CacheSharingMode = dagger.Shared
)

// Compression algorithm to use for image layers.
type ImageLayerCompression = dagger.ImageLayerCompression

const (
	Estargz ImageLayerCompression = dagger.Estargz

	Gzip ImageLayerCompression = dagger.Gzip

	Uncompressed ImageLayerCompression = dagger.Uncompressed

	Zstd ImageLayerCompression = dagger.Zstd
)

// Mediatypes to use in published or exported image metadata.
type ImageMediaTypes = dagger.ImageMediaTypes

const (
	Dockermediatypes ImageMediaTypes = dagger.Dockermediatypes

	Ocimediatypes ImageMediaTypes = dagger.Ocimediatypes
)

// The kind of module source.
type ModuleSourceKind = dagger.ModuleSourceKind

const (
	GitSource ModuleSourceKind = dagger.GitSource

	LocalSource ModuleSourceKind = dagger.LocalSource
)

// Transport layer network protocol associated to a port.
type NetworkProtocol = dagger.NetworkProtocol

const (
	Tcp NetworkProtocol = dagger.Tcp

	Udp NetworkProtocol = dagger.Udp
)

// Distinguishes the different kinds of TypeDefs.
type TypeDefKind = dagger.TypeDefKind

const (
	// A boolean value.
	BooleanKind TypeDefKind = dagger.BooleanKind

	// A graphql input type, used only when representing the core API via TypeDefs.
	InputKind TypeDefKind = dagger.InputKind

	// An integer value.
	IntegerKind TypeDefKind = dagger.IntegerKind

	// A named type of functions that can be matched+implemented by other objects+interfaces.
	//
	// Always paired with an InterfaceTypeDef.
	InterfaceKind TypeDefKind = dagger.InterfaceKind

	// A list of values all having the same type.
	//
	// Always paired with a ListTypeDef.
	ListKind TypeDefKind = dagger.ListKind

	// A named type defined in the GraphQL schema, with fields and functions.
	//
	// Always paired with an ObjectTypeDef.
	ObjectKind TypeDefKind = dagger.ObjectKind

	// A string value.
	StringKind TypeDefKind = dagger.StringKind

	// A special kind used to signify that no value is returned.
	//
	// This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
	VoidKind TypeDefKind = dagger.VoidKind
)

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Node) MarshalJSON() ([]byte, error) {
	var concrete struct {
		PipelineID      string
		Ctr             *Container
		Name            string
		Version         string
		DetectTest      bool
		DetectPackage   bool
		DetectLint      bool
		DetectOci       bool
		PkgMgr          string
		Platform        Platform
		IsProduction    bool
		SystemSetupCmds [][]string
		BaseImageRef    string
		NpmrcTokenName  string
		NpmrcToken      *Secret
		NpmrcFile       *Secret
		DistName        string
	}
	concrete.PipelineID = r.PipelineID
	concrete.Ctr = r.Ctr
	concrete.Name = r.Name
	concrete.Version = r.Version
	concrete.DetectTest = r.DetectTest
	concrete.DetectPackage = r.DetectPackage
	concrete.DetectLint = r.DetectLint
	concrete.DetectOci = r.DetectOci
	concrete.PkgMgr = r.PkgMgr
	concrete.Platform = r.Platform
	concrete.IsProduction = r.IsProduction
	concrete.SystemSetupCmds = r.SystemSetupCmds
	concrete.BaseImageRef = r.BaseImageRef
	concrete.NpmrcTokenName = r.NpmrcTokenName
	concrete.NpmrcToken = r.NpmrcToken
	concrete.NpmrcFile = r.NpmrcFile
	concrete.DistName = r.DistName
	return json.Marshal(&concrete)
}

func (r *Node) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		PipelineID      string
		Ctr             *Container
		Name            string
		Version         string
		DetectTest      bool
		DetectPackage   bool
		DetectLint      bool
		DetectOci       bool
		PkgMgr          string
		Platform        Platform
		IsProduction    bool
		SystemSetupCmds [][]string
		BaseImageRef    string
		NpmrcTokenName  string
		NpmrcToken      *Secret
		NpmrcFile       *Secret
		DistName        string
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.PipelineID = concrete.PipelineID
	r.Ctr = concrete.Ctr
	r.Name = concrete.Name
	r.Version = concrete.Version
	r.DetectTest = concrete.DetectTest
	r.DetectPackage = concrete.DetectPackage
	r.DetectLint = concrete.DetectLint
	r.DetectOci = concrete.DetectOci
	r.PkgMgr = concrete.PkgMgr
	r.Platform = concrete.Platform
	r.IsProduction = concrete.IsProduction
	r.SystemSetupCmds = concrete.SystemSetupCmds
	r.BaseImageRef = concrete.BaseImageRef
	r.NpmrcTokenName = concrete.NpmrcTokenName
	r.NpmrcToken = concrete.NpmrcToken
	r.NpmrcFile = concrete.NpmrcFile
	r.DistName = concrete.DistName
	return nil
}

func main() {
	ctx := context.Background()

	fnCall := dag.CurrentFunctionCall()
	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(2)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(2)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	_, err = fnCall.ReturnValue(ctx, JSON(resultBytes))
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
}

func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	switch parentName {
	case "Node":
		switch fnName {
		case "Container":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Container(&parent), nil
		case "Shell":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var cmd []string
			if inputArgs["cmd"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmd"]), &cmd)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmd", err))
				}
			}
			return (*Node).Shell(&parent, cmd), nil
		case "Serve":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Serve(&parent), nil
		case "WithPipelineId":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var pipelineId string
			if inputArgs["pipelineID"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pipelineID"]), &pipelineId)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pipelineID", err))
				}
			}
			return (*Node).WithPipelineId(&parent, pipelineId), nil
		case "SetupSystem":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var systemSetupCmds [][]string
			if inputArgs["systemSetupCmds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["systemSetupCmds"]), &systemSetupCmds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg systemSetupCmds", err))
				}
			}
			return (*Node).SetupSystem(&parent, systemSetupCmds), nil
		case "Do":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Do(&parent, ctx)
		case "OciBuild":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var folderArtifactNames []string
			if inputArgs["folderArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifactNames"]), &folderArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifactNames", err))
				}
			}
			var folderArtifacts []*Directory
			if inputArgs["folderArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifacts"]), &folderArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifacts", err))
				}
			}
			var fileArtifactNames []string
			if inputArgs["fileArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifactNames"]), &fileArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifactNames", err))
				}
			}
			var fileArtifacts []*File
			if inputArgs["fileArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifacts"]), &fileArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifacts", err))
				}
			}
			var fileContainerArtifacts []string
			if inputArgs["fileContainerArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileContainerArtifacts"]), &fileContainerArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileContainerArtifacts", err))
				}
			}
			var directoryContainerArtifacts []string
			if inputArgs["directoryContainerArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["directoryContainerArtifacts"]), &directoryContainerArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg directoryContainerArtifacts", err))
				}
			}
			var registries []string
			if inputArgs["registries"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registries"]), &registries)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registries", err))
				}
			}
			var isTtl bool
			if inputArgs["isTtl"] != nil {
				err = json.Unmarshal([]byte(inputArgs["isTtl"]), &isTtl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg isTtl", err))
				}
			}
			var ttlRegistry string
			if inputArgs["ttlRegistry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ttlRegistry"]), &ttlRegistry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ttlRegistry", err))
				}
			}
			var ttl string
			if inputArgs["ttl"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ttl"]), &ttl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ttl", err))
				}
			}
			return (*Node).OciBuild(&parent, ctx, folderArtifactNames, folderArtifacts, fileArtifactNames, fileArtifacts, fileContainerArtifacts, directoryContainerArtifacts, registries, isTtl, ttlRegistry, ttl)
		case "WithVersion":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var isAlpine bool
			if inputArgs["isAlpine"] != nil {
				err = json.Unmarshal([]byte(inputArgs["isAlpine"]), &isAlpine)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg isAlpine", err))
				}
			}
			return (*Node).WithVersion(&parent, image, version, isAlpine), nil
		case "WithNpmrcTokenEnv":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var value *Secret
			if inputArgs["value"] != nil {
				err = json.Unmarshal([]byte(inputArgs["value"]), &value)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg value", err))
				}
			}
			return (*Node).WithNpmrcTokenEnv(&parent, name, value), nil
		case "WithNpmrcTokenFile":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var npmrcFile *Secret
			if inputArgs["npmrcFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["npmrcFile"]), &npmrcFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg npmrcFile", err))
				}
			}
			return (*Node).WithNpmrcTokenFile(&parent, npmrcFile), nil
		case "WithPackageManager":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var packageManager string
			if inputArgs["packageManager"] != nil {
				err = json.Unmarshal([]byte(inputArgs["packageManager"]), &packageManager)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg packageManager", err))
				}
			}
			var disableCache bool
			if inputArgs["disableCache"] != nil {
				err = json.Unmarshal([]byte(inputArgs["disableCache"]), &disableCache)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg disableCache", err))
				}
			}
			return (*Node).WithPackageManager(&parent, packageManager, disableCache), nil
		case "WithNpm":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var disableCache bool
			if inputArgs["disableCache"] != nil {
				err = json.Unmarshal([]byte(inputArgs["disableCache"]), &disableCache)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg disableCache", err))
				}
			}
			return (*Node).WithNpm(&parent, disableCache), nil
		case "WithYarn":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var disableCache bool
			if inputArgs["disableCache"] != nil {
				err = json.Unmarshal([]byte(inputArgs["disableCache"]), &disableCache)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg disableCache", err))
				}
			}
			return (*Node).WithYarn(&parent, disableCache), nil
		case "WithSource":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var src *Directory
			if inputArgs["src"] != nil {
				err = json.Unmarshal([]byte(inputArgs["src"]), &src)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg src", err))
				}
			}
			var persisted bool
			if inputArgs["persisted"] != nil {
				err = json.Unmarshal([]byte(inputArgs["persisted"]), &persisted)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg persisted", err))
				}
			}
			return (*Node).WithSource(&parent, src, persisted), nil
		case "Production":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Production(&parent), nil
		case "Run":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var command []string
			if inputArgs["command"] != nil {
				err = json.Unmarshal([]byte(inputArgs["command"]), &command)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg command", err))
				}
			}
			return (*Node).Run(&parent, command), nil
		case "Install":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Install(&parent), nil
		case "Lint":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Lint(&parent), nil
		case "Test":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var folderArtifactNames []string
			if inputArgs["folderArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifactNames"]), &folderArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifactNames", err))
				}
			}
			var folderArtifacts []*Directory
			if inputArgs["folderArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifacts"]), &folderArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifacts", err))
				}
			}
			var fileArtifactNames []string
			if inputArgs["fileArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifactNames"]), &fileArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifactNames", err))
				}
			}
			var fileArtifacts []*File
			if inputArgs["fileArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifacts"]), &fileArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifacts", err))
				}
			}
			var cacheArtifactNames []string
			if inputArgs["cacheArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cacheArtifactNames"]), &cacheArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cacheArtifactNames", err))
				}
			}
			var cacheArtifacts []string
			if inputArgs["cacheArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cacheArtifacts"]), &cacheArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cacheArtifacts", err))
				}
			}
			return (*Node).Test(&parent, folderArtifactNames, folderArtifacts, fileArtifactNames, fileArtifacts, cacheArtifactNames, cacheArtifacts), nil
		case "ParallelTest":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var folderArtifactNames []string
			if inputArgs["folderArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifactNames"]), &folderArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifactNames", err))
				}
			}
			var folderArtifacts []*Directory
			if inputArgs["folderArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["folderArtifacts"]), &folderArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg folderArtifacts", err))
				}
			}
			var fileArtifactNames []string
			if inputArgs["fileArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifactNames"]), &fileArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifactNames", err))
				}
			}
			var fileArtifacts []*File
			if inputArgs["fileArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileArtifacts"]), &fileArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileArtifacts", err))
				}
			}
			var cacheArtifactNames []string
			if inputArgs["cacheArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cacheArtifactNames"]), &cacheArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cacheArtifactNames", err))
				}
			}
			var cacheArtifacts []string
			if inputArgs["cacheArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cacheArtifacts"]), &cacheArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cacheArtifacts", err))
				}
			}
			var cmds [][]string
			if inputArgs["cmds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmds"]), &cmds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmds", err))
				}
			}
			return nil, (*Node).ParallelTest(&parent, ctx, folderArtifactNames, folderArtifacts, fileArtifactNames, fileArtifacts, cacheArtifactNames, cacheArtifacts, cmds)
		case "Clean":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Clean(&parent), nil
		case "Build":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Node).Build(&parent), nil
		case "Publish":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var access string
			if inputArgs["access"] != nil {
				err = json.Unmarshal([]byte(inputArgs["access"]), &access)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg access", err))
				}
			}
			var devTag string
			if inputArgs["devTag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["devTag"]), &devTag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg devTag", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			return (*Node).Publish(&parent, access, devTag, dryRun), nil
		case "WithAutoSetup":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var pipelineId string
			if inputArgs["pipelineId"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pipelineId"]), &pipelineId)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pipelineId", err))
				}
			}
			var src *Directory
			if inputArgs["src"] != nil {
				err = json.Unmarshal([]byte(inputArgs["src"]), &src)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg src", err))
				}
			}
			var patternExclusions []string
			if inputArgs["patternExclusions"] != nil {
				err = json.Unmarshal([]byte(inputArgs["patternExclusions"]), &patternExclusions)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg patternExclusions", err))
				}
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var isAlpine bool
			if inputArgs["isAlpine"] != nil {
				err = json.Unmarshal([]byte(inputArgs["isAlpine"]), &isAlpine)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg isAlpine", err))
				}
			}
			var containerPlatform Platform
			if inputArgs["containerPlatform"] != nil {
				err = json.Unmarshal([]byte(inputArgs["containerPlatform"]), &containerPlatform)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg containerPlatform", err))
				}
			}
			var systemSetupCmds [][]string
			if inputArgs["systemSetupCmds"] != nil {
				err = json.Unmarshal([]byte(inputArgs["systemSetupCmds"]), &systemSetupCmds)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg systemSetupCmds", err))
				}
			}
			return (*Node).WithAutoSetup(&parent, ctx, pipelineId, src, patternExclusions, image, isAlpine, containerPlatform, systemSetupCmds)
		case "Pipeline":
			var parent Node
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var preHooks [][]string
			if inputArgs["preHooks"] != nil {
				err = json.Unmarshal([]byte(inputArgs["preHooks"]), &preHooks)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg preHooks", err))
				}
			}
			var postHooks [][]string
			if inputArgs["postHooks"] != nil {
				err = json.Unmarshal([]byte(inputArgs["postHooks"]), &postHooks)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg postHooks", err))
				}
			}
			var isOci bool
			if inputArgs["isOci"] != nil {
				err = json.Unmarshal([]byte(inputArgs["isOci"]), &isOci)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg isOci", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			var packageAccess string
			if inputArgs["packageAccess"] != nil {
				err = json.Unmarshal([]byte(inputArgs["packageAccess"]), &packageAccess)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg packageAccess", err))
				}
			}
			var packageDevTag string
			if inputArgs["packageDevTag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["packageDevTag"]), &packageDevTag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg packageDevTag", err))
				}
			}
			var testFolderArtifactNames []string
			if inputArgs["testFolderArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testFolderArtifactNames"]), &testFolderArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testFolderArtifactNames", err))
				}
			}
			var testFolderArtifacts []*Directory
			if inputArgs["testFolderArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testFolderArtifacts"]), &testFolderArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testFolderArtifacts", err))
				}
			}
			var testFileArtifactNames []string
			if inputArgs["testFileArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testFileArtifactNames"]), &testFileArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testFileArtifactNames", err))
				}
			}
			var testFileArtifacts []*File
			if inputArgs["testFileArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testFileArtifacts"]), &testFileArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testFileArtifacts", err))
				}
			}
			var testCacheArtifactNames []string
			if inputArgs["testCacheArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testCacheArtifactNames"]), &testCacheArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testCacheArtifactNames", err))
				}
			}
			var testCacheArtifacts []string
			if inputArgs["testCacheArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testCacheArtifacts"]), &testCacheArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testCacheArtifacts", err))
				}
			}
			var ociFolderArtifactNames []string
			if inputArgs["ociFolderArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ociFolderArtifactNames"]), &ociFolderArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ociFolderArtifactNames", err))
				}
			}
			var ociFolderArtifacts []*Directory
			if inputArgs["ociFolderArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ociFolderArtifacts"]), &ociFolderArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ociFolderArtifacts", err))
				}
			}
			var ociFileArtifactNames []string
			if inputArgs["ociFileArtifactNames"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ociFileArtifactNames"]), &ociFileArtifactNames)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ociFileArtifactNames", err))
				}
			}
			var ociFileArtifacts []*File
			if inputArgs["ociFileArtifacts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ociFileArtifacts"]), &ociFileArtifacts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ociFileArtifacts", err))
				}
			}
			var ociRegistries []string
			if inputArgs["ociRegistries"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ociRegistries"]), &ociRegistries)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ociRegistries", err))
				}
			}
			var ttlRegistry string
			if inputArgs["ttlRegistry"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ttlRegistry"]), &ttlRegistry)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ttlRegistry", err))
				}
			}
			var ttl string
			if inputArgs["ttl"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ttl"]), &ttl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ttl", err))
				}
			}
			return (*Node).Pipeline(&parent, ctx, preHooks, postHooks, isOci, dryRun, packageAccess, packageDevTag, testFolderArtifactNames, testFolderArtifacts, testFileArtifactNames, testFileArtifacts, testCacheArtifactNames, testCacheArtifacts, ociFolderArtifactNames, ociFolderArtifacts, ociFileArtifactNames, ociFileArtifacts, ociRegistries, ttlRegistry, ttl)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "":
		return dag.Module().
			WithDescription("A generated module for Node functions\n\nThis module has been generated via dagger init and serves as a reference to\nbasic module structure as you get started with Dagger.\n\nTwo functions have been pre-created. You can modify, delete, or add to them,\nas needed. They demonstrate usage of arguments and return types using simple\necho and grep commands. The functions can be called from the dagger CLI or\nfrom one of the SDKs.\n\nThe first line in this comment block is a short description line and the\nrest is a long description with more detail on the module's purpose or usage,\nif appropriate. All modules should have a short description.\n").
			WithObject(
				dag.TypeDef().WithObject("Node").
					WithFunction(
						dag.Function("Container",
							dag.TypeDef().WithObject("Container")).
							WithDescription("Return the current container state")).
					WithFunction(
						dag.Function("Shell",
							dag.TypeDef().WithObject("Terminal")).
							WithDescription("Open a shell in the current container or execute a command inside it, like node").
							WithArg("cmd", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "The command to execute in the terminal"})).
					WithFunction(
						dag.Function("Serve",
							dag.TypeDef().WithObject("Service")).
							WithDescription("Expose the container as a service")).
					WithFunction(
						dag.Function("WithPipelineId",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Define the pipeline id to use").
							WithArg("pipelineID", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "The name to give to the pipeline"})).
					WithFunction(
						dag.Function("SetupSystem",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Setup system component like installing packages").
							WithArg("systemSetupCmds", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).WithOptional(true), FunctionWithArgOpts{Description: "Indicate attempted system package to install"})).
					WithFunction(
						dag.Function("Do",
							dag.TypeDef().WithKind(StringKind)).
							WithDescription("Execute all commands")).
					WithFunction(
						dag.Function("OciBuild",
							dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).
							WithDescription("Build a production image and push to one or more registries").
							WithArg("folderArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define folder names to map in the working directory, these names match 'folder-artifacts'"}).
							WithArg("folderArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Directory")).WithOptional(true), FunctionWithArgOpts{Description: "Define folders to map in the working directory, these folders match 'folder-artifact-names'"}).
							WithArg("fileArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define files to mount in the working directory, these names match 'file-artifact-names'"}).
							WithArg("fileArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("File")).WithOptional(true), FunctionWithArgOpts{Description: "Define file names to map in the working directory, these names match 'file-artifacts'"}).
							WithArg("fileContainerArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define path to fo file to fetch from the build container"}).
							WithArg("directoryContainerArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define path to fo directories to fetch from the build container"}).
							WithArg("registries", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)), FunctionWithArgOpts{Description: "Define registries where to push the image"}).
							WithArg("isTtl", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Define the ttl registry to use"}).
							WithArg("ttlRegistry", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define the ttl registry to use", DefaultValue: JSON("\"ttl.sh\"")}).
							WithArg("ttl", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define the ttl in the ttl registry", DefaultValue: JSON("\"60m\"")})).
					WithFunction(
						dag.Function("WithVersion",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with the right base image").
							WithArg("image", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "The image name to use", DefaultValue: JSON("\"node\"")}).
							WithArg("version", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "The version of the image to use"}).
							WithArg("isAlpine", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Define if the image to use is an alpine or not", DefaultValue: JSON("\"true\"")})).
					WithFunction(
						dag.Function("WithNpmrcTokenEnv",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with an environment variable to use in your npmrc file").
							WithArg("name", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "The name of the environment variable where the npmrc token is stored"}).
							WithArg("value", dag.TypeDef().WithObject("Secret"), FunctionWithArgOpts{Description: "The value of the token"})).
					WithFunction(
						dag.Function("WithNpmrcTokenFile",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with npmrc file").
							WithArg("npmrcFile", dag.TypeDef().WithObject("Secret"), FunctionWithArgOpts{Description: "The npmrc file to inject in the container"})).
					WithFunction(
						dag.Function("WithPackageManager",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container setup with the right package manager and optionaly cache setup").
							WithArg("packageManager", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "The package manager to use"}).
							WithArg("disableCache", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Disable mounting cache volumes."})).
					WithFunction(
						dag.Function("WithNpm",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with npm setup as an entrypoint and npm cache setup").
							WithArg("disableCache", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Disable mounting cache volumes."})).
					WithFunction(
						dag.Function("WithYarn",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with yarn setup as an entrypoint and yarn cache setup").
							WithArg("disableCache", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Disable mounting cache volumes."})).
					WithFunction(
						dag.Function("WithSource",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return the Node container with the source code, 'node_modules' cache set up and workdir set").
							WithArg("src", dag.TypeDef().WithObject("Directory"), FunctionWithArgOpts{Description: "The source code"}).
							WithArg("persisted", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate if the directory is mounted or persisted in the container"})).
					WithFunction(
						dag.Function("Production",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Return a node container with the 'NODE_ENV' set to production")).
					WithFunction(
						dag.Function("Run",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute a command from the package.json").
							WithArg("command", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)), FunctionWithArgOpts{Description: "Command from the package.json to run"})).
					WithFunction(
						dag.Function("Install",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Install node modules")).
					WithFunction(
						dag.Function("Lint",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute lint command")).
					WithFunction(
						dag.Function("Test",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute test command").
							WithArg("folderArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define folder names to mount for testing, these names match 'folder-artifacts'"}).
							WithArg("folderArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Directory")).WithOptional(true), FunctionWithArgOpts{Description: "Define folders to map in the working directory for testing, these folders match 'folder-artifact-names'"}).
							WithArg("fileArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define files to mount in the working directory for testing, these names match 'file-artifact-names'"}).
							WithArg("fileArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("File")).WithOptional(true), FunctionWithArgOpts{Description: "Define file names to map in the working directory for testing, these names match 'file-artifacts'"}).
							WithArg("cacheArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact names to mount for testing, these names match 'cache-artifacts'"}).
							WithArg("cacheArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact to map in the working directory for testing, these folders match 'cache-artifact-names'"})).
					WithFunction(
						dag.Function("ParallelTest",
							dag.TypeDef().WithKind(VoidKind).WithOptional(true)).
							WithDescription("Execute test commands in parallel").
							WithArg("folderArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define folder names to mount for testing, these names match 'folder-artifacts'"}).
							WithArg("folderArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Directory")).WithOptional(true), FunctionWithArgOpts{Description: "Define folders to map in the working directory for testing, these folders match 'folder-artifact-names'"}).
							WithArg("fileArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define files to mount in the working directoryf or testing, these names match 'file-artifact-names'"}).
							WithArg("fileArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("File")).WithOptional(true), FunctionWithArgOpts{Description: "Define file names to map in the working directory or testing, these names match 'file-artifacts'"}).
							WithArg("cacheArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact names to mount for testing or testing, these names match 'cache-artifacts'"}).
							WithArg("cacheArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact to map in the working directory or testing, these folders match 'cache-artifact-names'"}).
							WithArg("cmds", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))), FunctionWithArgOpts{Description: "Define all command to run"})).
					WithFunction(
						dag.Function("Clean",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute clean command")).
					WithFunction(
						dag.Function("Build",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute the build command")).
					WithFunction(
						dag.Function("Publish",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Execute the publish which push a package to a registry").
							WithArg("access", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define permission on the package in the registry"}).
							WithArg("devTag", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate if the package is publishing as development version"}).
							WithArg("dryRun", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate to dry run the publishing"})).
					WithFunction(
						dag.Function("WithAutoSetup",
							dag.TypeDef().WithObject("Node")).
							WithDescription("Allow to let the pipeline to be setup automatically based on the package.json aka lazy mode").
							WithArg("pipelineId", dag.TypeDef().WithKind(StringKind), FunctionWithArgOpts{Description: "A name to use in the pipeline and injected in cache keys"}).
							WithArg("src", dag.TypeDef().WithObject("Directory"), FunctionWithArgOpts{Description: "The code to mount in the node container"}).
							WithArg("patternExclusions", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Patterns to exclude in the analysis for the auto-detection"}).
							WithArg("image", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "The image name to use", DefaultValue: JSON("\"node\"")}).
							WithArg("isAlpine", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Define if the image to use is an alpine or not", DefaultValue: JSON("\"true\"")}).
							WithArg("containerPlatform", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Container options", DefaultValue: JSON("\"linux/amd64\"")}).
							WithArg("systemSetupCmds", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).WithOptional(true), FunctionWithArgOpts{Description: "Indicate attempted system package to install"})).
					WithFunction(
						dag.Function("Pipeline",
							dag.TypeDef().WithKind(StringKind)).
							WithDescription("Execute the whole pipeline in general used with the function 'with-auto-setup'").
							WithArg("preHooks", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).WithOptional(true), FunctionWithArgOpts{Description: "Define hooks to execute before all"}).
							WithArg("postHooks", dag.TypeDef().WithListOf(dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind))).WithOptional(true), FunctionWithArgOpts{Description: "Define hooks to execute after tests and before build"}).
							WithArg("isOci", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate if the artifact is an oci build or not"}).
							WithArg("dryRun", dag.TypeDef().WithKind(BooleanKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate to dry run the publishing", DefaultValue: JSON("\"false\"")}).
							WithArg("packageAccess", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define permission on the package in the registry", DefaultValue: JSON("\"true\"")}).
							WithArg("packageDevTag", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Indicate if the package is publishing as development version"}).
							WithArg("testFolderArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define folder names to mount for testing, these names match 'folder-artifacts'"}).
							WithArg("testFolderArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Directory")).WithOptional(true), FunctionWithArgOpts{Description: "Define folders to map in the working directory for testing, these folders match 'test-folder-artifact-names'"}).
							WithArg("testFileArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define files to mount in the working directoryf or testing, these names match 'test-file-artifact-names'"}).
							WithArg("testFileArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("File")).WithOptional(true), FunctionWithArgOpts{Description: "Define file names to map in the working directory or testing, these names match 'test-file-artifacts'"}).
							WithArg("testCacheArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact names to mount for testing or testing, these names match 'test-cache-artifacts'"}).
							WithArg("testCacheArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define artifact to map in the working directory or testing, these folders match 'test-cache-artifact-names'"}).
							WithArg("ociFolderArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define folder names to map in the working directory, these names match 'folder-artifacts'"}).
							WithArg("ociFolderArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("Directory")).WithOptional(true), FunctionWithArgOpts{Description: "Define folders to map in the working directory, these folders match 'folder-artifact-names'"}).
							WithArg("ociFileArtifactNames", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define files to mount in the working directory, these names match 'file-artifact-names'"}).
							WithArg("ociFileArtifacts", dag.TypeDef().WithListOf(dag.TypeDef().WithObject("File")).WithOptional(true), FunctionWithArgOpts{Description: "Define file names to map in the working directory, these names match 'file-artifacts'"}).
							WithArg("ociRegistries", dag.TypeDef().WithListOf(dag.TypeDef().WithKind(StringKind)).WithOptional(true), FunctionWithArgOpts{Description: "Define registries where to push the image"}).
							WithArg("ttlRegistry", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define the ttl registry to use", DefaultValue: JSON("\"ttl.sh\"")}).
							WithArg("ttl", dag.TypeDef().WithKind(StringKind).WithOptional(true), FunctionWithArgOpts{Description: "Define the ttl in the ttl registry", DefaultValue: JSON("\"60m\"")}))), nil
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
